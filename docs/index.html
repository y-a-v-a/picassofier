<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Les gens d&apos;Internet</title>
    <style>
      body {
        margin: 0;
      }

      #wall {
        display: grid;
        grid-template-columns: 1fr 1fr;
      }

      .input {
        display: none;
      }

      .input img {
        width: 100%;
      }

      .output {
        /* grid-column-start: 2; */
        grid-column-start: span 2;
      }
      .no-toolbar .output {
        grid-column-start: span 2;
      }

      .output img {
        width: 100%;
        max-width: 100vh;
        max-height: 80vh;
        margin: 0 auto;
      }

      .titlebar {
        text-align: center;
      }
      .titlebar,
      .toolbar {
        grid-column-start: span 2;
      }

      .no-toolbar .toolbar {
        display: none;
      }

      canvas,
      img {
        display: block;
      }

      #canvasInput,
      #canvasOutput {
        display: none;
      }

      .switch {
        cursor: pointer;
      }

      .no-toolbar .moins,
      .plus {
        display: none;
      }
      .moins,
      .no-toolbar .plus {
        display: inline;
      }
    </style>
    <link rel="icon" href="data:," />
  </head>

  <body class="no-toolbar">
    <div id="wall">
      <div class="input">
        <img id="imageSrc" alt="No Image" src="./group.png" />
      </div>
      <div class="output">
        <img
          src="data:image/gif;base64,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"
          alt="no image"
          id="outputImage"
        />
      </div>

      <div class="titlebar">
        <h1>Les gens d&apos;Internet – après Picasso</h1>
        <h2>Ultima-Cubism, 2018-2023, “Encore un Autre Artiste Plasticien”</h2>
        <p>
          Technique: pixels sur l'écran
          <span class="switch">
            <span class="plus">plus...</span>
            <span class="moins">moins...</span>
          </span>
        </p>
      </div>
      <div class="toolbar">
        <span class="caption">To upload: <input type="file" id="fileInput" name="file" /></span>
        <p id="status">OpenCV.js is loading...</p>
      </div>
    </div>

    <canvas id="canvasInput"></canvas>
    <canvas id="canvasOutput"></canvas>

    <script>
      const toolbarSwitch = document.querySelector('.switch');
      toolbarSwitch.addEventListener('click', () => document.body.classList.toggle('no-toolbar'));

      const imgElement = document.getElementById('imageSrc');
      const maskElement = document.getElementById('mask');
      const inputElement = document.getElementById('fileInput');
      const canvasOutput = document.getElementById('canvasOutput');
      const outputImage = document.getElementById('outputImage');

      // preload some masks
      const masks = [...Array(6)].map((el, idx) => {
        const img = new Image();
        img.src = `./masks/mask${idx}.png`;
        return img;
      });

      inputElement.addEventListener(
        'change',
        e => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
        },
        false
      );

      imgElement.onload = () => {
        window.cv && processImage();
      };

      function processImage() {
        const edgeOffset = 0.04;

        let mat = cv.imread(imgElement, cv.IMREAD_UNCHANGED);

        cv.imshow('canvasInput', mat);
        mat.delete();

        let src = cv.imread('canvasInput', cv.IMREAD_UNCHANGED);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        const srcWidth = src.cols;
        const srcHeight = src.rows;

        let faceCascade = new cv.CascadeClassifier();
        faceCascade.load('haarcascade_frontalface_default.xml');

        let faces = new cv.RectVector();
        let minSize = new cv.Size(0, 0);
        let maxSize = new cv.Size(100, 100);
        faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, minSize, maxSize);

        // roi = region of interest
        // mat = matrix
        for (let i = 0; i < faces.size(); ++i) {
          let mask = cv.imread(
            masks[Math.floor(masks.length * Math.random())],
            cv.IMREAD_UNCHANGED
          );

          let maskConverted = new cv.Mat();
          cv.cvtColor(mask, maskConverted, cv.COLOR_RGB2RGBA, 0);

          let roiGray = gray.roi(faces.get(i));
          let roiSrc = src.roi(faces.get(i));
          //   let point1 = new cv.Point(faces.get(i).x, faces.get(i).y);
          //   let point2 = new cv.Point(
          //     faces.get(i).x + faces.get(i).width,
          //     faces.get(i).y + faces.get(i).height
          //   );
          //   cv.rectangle(src, point1, point2, [255, 0, 0, 255]);

          // take a little more space than the found face rect
          // this better positions the mask on the found face
          const edgeXOffset = Math.floor(srcWidth * edgeOffset);
          const edgeYOffset = Math.floor(srcHeight * edgeOffset);

          const width = faces.get(i).width + edgeXOffset;
          const height = faces.get(i).height + edgeYOffset;

          const faceSize = new cv.Size(width, height);
          let resizedMask = new cv.Mat();
          cv.resize(maskConverted, resizedMask, faceSize, cv.INTER_AREA);

          let maskRect = new cv.Rect(0, 0, width, height);
          let maskRoi = resizedMask.roi(maskRect);

          faceXOffset = Math.max(faces.get(i).x - Math.round(edgeXOffset / 2), 0);
          faceYOffset = Math.max(faces.get(i).y - Math.round(edgeYOffset / 2), 0);

          let faceRect = new cv.Rect(faceXOffset, faceYOffset, width, height);
          let faceRoi = src.roi(faceRect);

          // loop over pixels in face roi
          for (let x = 0; x < faceRoi.rows; x++) {
            for (let y = 0; y < faceRoi.cols; y++) {
              const srcPixel = maskRoi?.row(x)?.col(y);
              const alpha = srcPixel.data[3] / 255; // alpha between 0 and 1

              // only if srcPixel is _not_ transparent, draw it on the dest
              if (alpha === 1) {
                faceRoi.ucharPtr(x, y)[0] = srcPixel.data[0];
                faceRoi.ucharPtr(x, y)[1] = srcPixel.data[1];
                faceRoi.ucharPtr(x, y)[2] = srcPixel.data[2];
                faceRoi.ucharPtr(x, y)[3] = srcPixel.data[3];
              }
            }
          }

          mask.delete();
          maskConverted.delete();
          resizedMask.delete();
          maskRoi.delete();
          faceRoi.delete();
          roiGray.delete();
          roiSrc.delete();
        }

        // intermediately write result to a canvas
        cv.imshow('canvasOutput', src);

        src.delete();
        gray.delete();
        faceCascade.delete();
        faces.delete();

        // read canvas image data in jpeg compression 0 to get max cubism
        const image = canvasOutput.toDataURL('image/jpeg', 0);
        // write result to visible img element
        outputImage.src = image;
      }

      const Module = {
        // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
        async onRuntimeInitialized() {
          document.getElementById('status').innerHTML = 'OpenCV.js is ready.';

          const response = await fetch('./haarcascade_frontalface_default.xml');
          const buffer = await response.arrayBuffer();
          const data = new Uint8Array(buffer);
          cv.FS_createDataFile(
            '/',
            'haarcascade_frontalface_default.xml',
            data,
            true,
            false,
            false
          );

          processImage();
        },
      };
    </script>
    <script async src="./opencv.js"></script>
    <!-- <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script> -->
  </body>
</html>
